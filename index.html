<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Model Chat</title>
    <!-- Markdown and LaTeX rendering libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #4a90e2 0%, #2c5282 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 15px;
                margin-bottom: 15px;
            }
        }

        .header h1 {
            font-size: 28px;
            color: #333;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #4a90e2 0%, #2c5282 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 22px;
            }
        }

        .api-key-display {
            background: #f0f0f0;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            color: #666;
            word-break: break-all;
            display: inline-block;
            max-width: 100%;
        }
        
        @media (max-width: 768px) {
            .api-key-display {
                padding: 6px 10px;
                font-size: 10px;
            }
        }

        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 20px;
            padding: 20px 0;
        }
        
        @media (max-width: 768px) {
            .models-grid {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 10px 0;
            }
        }

        .model-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        @media (max-width: 768px) {
            .model-card {
                padding: 12px;
                max-height: 300px;
            }
        }

        .model-header {
            font-weight: 600;
            color: #333;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .model-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 12px;
            background: #e0e0e0;
            color: #666;
        }

        .model-status.loading {
            background: #fff3cd;
            color: #856404;
            animation: pulse 1.5s infinite;
        }

        .model-status.success {
            background: #d4edda;
            color: #155724;
        }

        .model-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .model-response {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            word-wrap: break-word;
        }
        
        .model-response h1, .model-response h2, .model-response h3 {
            margin-top: 16px;
            margin-bottom: 8px;
        }
        
        .model-response h1:first-child, .model-response h2:first-child, .model-response h3:first-child {
            margin-top: 0;
        }
        
        .model-response p {
            margin: 8px 0;
        }
        
        .model-response ul, .model-response ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .model-response li {
            margin: 4px 0;
        }
        
        .model-response code {
            background: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .model-response pre {
            background: #f0f0f0;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        .model-response pre code {
            background: none;
            padding: 0;
        }
        
        .model-response blockquote {
            border-left: 4px solid #ddd;
            margin: 8px 0;
            padding-left: 16px;
            color: #666;
        }

        .model-response.loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
        }

        .chat-history {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid #e0e0e0;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .chat-history {
                max-height: 250px;
                padding: 10px;
            }
        }
        
        .chat-history:empty {
            display: none;
            margin: 0;
            padding: 0;
            border: none;
        }

        .message {
            padding: 10px 14px;
            border-radius: 8px;
            margin: 0;
        }

        .message.user {
            background: linear-gradient(135deg, #4a90e2 0%, #2c5282 100%);
            color: white;
            align-self: flex-end;
            max-width: 80%;
        }

        .message.system {
            background: #f0f0f0;
            color: #666;
            font-style: italic;
            align-self: flex-start;
            max-width: 80%;
            font-size: 13px;
        }

        .message.system.clickable {
            cursor: pointer;
            transition: background 0.2s;
        }

        .message.system.clickable:hover {
            background: #e0e0e0;
        }

        .input-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .save-comparison-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 14px 32px;
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        
        .save-comparison-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
        }
        
        .save-comparison-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        @media (max-width: 768px) {
            .input-container {
                padding: 15px;
            }
        }

        .input-form {
            display: flex;
            gap: 12px;
        }
        
        @media (max-width: 768px) {
            .input-form {
                flex-direction: column;
                gap: 10px;
            }
        }

        .message-input {
            flex: 1;
            padding: 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            transition: border-color 0.3s;
            font-family: inherit;
            resize: none;
            overflow-y: hidden;
            min-height: 48px;
            max-height: 200px;
        }
        
        @media (max-width: 768px) {
            .message-input {
                padding: 12px;
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }

        .message-input:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .send-button {
            padding: 14px 32px;
            background: linear-gradient(135deg, #4a90e2 0%, #2c5282 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        @media (max-width: 768px) {
            .send-button {
                padding: 14px 20px;
                font-size: 16px;
            }
        }

        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .no-api-key {
            background: white;
            border-radius: 12px;
            padding: 60px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .no-api-key {
                padding: 30px 20px;
            }
        }

        .no-api-key h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        @media (max-width: 768px) {
            .no-api-key h2 {
                font-size: 24px;
            }
        }

        .no-api-key p {
            color: #666;
            line-height: 1.8;
            margin-bottom: 24px;
            font-size: 16px;
        }

        .no-api-key code {
            background: #f0f0f0;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            display: inline-block;
            margin: 20px 0;
            font-size: 14px;
            word-break: break-all;
            max-width: 100%;
        }
        
        @media (max-width: 768px) {
            .no-api-key code {
                padding: 10px;
                font-size: 12px;
            }
        }

        .no-api-key a {
            color: #4a90e2;
            text-decoration: none;
            font-weight: 600;
        }

        .no-api-key a:hover {
            text-decoration: underline;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .error-text {
            color: #c00;
        }

        .response-time {
            font-size: 11px;
            color: #999;
            margin-top: 8px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal h2 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
        }
        
        .modal-input {
            width: 100%;
            padding: 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            margin-bottom: 20px;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
        }
        
        .modal-input:focus {
            outline: none;
            border-color: #4a90e2;
        }
        
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .modal-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .modal-button.primary {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: white;
        }
        
        .modal-button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
        }
        
        .modal-button.secondary {
            background: #f0f0f0;
            color: #666;
        }
        
        .modal-button.secondary:hover {
            background: #e0e0e0;
        }
        
        @media (max-width: 768px) {
            .modal {
                padding: 24px;
                width: 95%;
            }
            
            .modal h2 {
                font-size: 20px;
            }
            
            .modal-buttons {
                flex-direction: column-reverse;
            }
            
            .modal-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">

        <div id="mainContent">
            <!-- Content will be inserted here by JavaScript -->
        </div>
    </div>

    <script>
        // Get API key from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        
        // Auto-redirect if no parameters at all
        if (!window.location.search) {
            window.location.href = window.location.pathname + '?api_key=';
        }
        
        const apiKey = urlParams.get('apiKey') || urlParams.get('api_key');
        const baseUrl = 'https://api.poe.com/v1';
        
        // Do NOT hardcode models in this list
        let models = [];

        let messages = [];
        
        // Store responses for each request
        let requestResponses = {};
        
        // Track which models are currently loading
        let modelsLoading = new Set();
        
        // Queue for messages waiting to be processed
        let messageQueue = [];

        // Function to fetch available models from Poe API
        async function fetchAvailableModels() {
            try {
                const response = await fetch(`${baseUrl}/models`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch models: ${response.status}`);
                }
                
                const data = await response.json();
                // Extract model IDs from the response
                return data.data.map(model => model.id);
            } catch (error) {
                console.error('Error fetching models:', error);
                return null;
            }
        }

        async function initializeApp() {
            const mainContent = document.getElementById('mainContent');
            const conversationId = urlParams.get('conversation_id');
            
            // Determine which view to show
            if (conversationId) {
                // Archive view - show saved conversation (no API key needed)
                await showArchiveView(conversationId);
            } else if (apiKey) {
                // Chat view - show chat interface
                await showChatView();
            } else {
                // Home page - show saved conversations list
                await showHomePage();
            }
        }
        
        async function showHomePage() {
            const mainContent = document.getElementById('mainContent');
            
            // Start with the API key input box
            let htmlContent = `
                <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                    <h2 style="font-size: 20px; color: #333; margin-bottom: 20px;">Start a New Chat</h2>
                    <form onsubmit="event.preventDefault(); const apiKey = document.getElementById('apiKeyInput').value.trim(); if(apiKey) window.location.href='?api_key=' + encodeURIComponent(apiKey);">
                        <input type="text" id="apiKeyInput" placeholder="Enter your Poe API key" style="
                            width: 100%;
                            padding: 14px;
                            border: 2px solid #e0e0e0;
                            border-radius: 8px;
                            font-size: 15px;
                            margin-bottom: 15px;
                        ">
                        <button type="submit" style="
                            padding: 14px 32px;
                            background: linear-gradient(135deg, #4a90e2 0%, #2c5282 100%);
                            color: white;
                            border: none;
                            border-radius: 8px;
                            font-size: 15px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: transform 0.2s, box-shadow 0.2s;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(74, 144, 226, 0.4)'" 
                           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                            Start Chat →
                        </button>
                    </form>
                    <p style="margin-top: 15px; color: #666; font-size: 14px;">
                        Get your API key from <a href="https://poe.com/api_key" target="_blank" style="color: #4a90e2;">poe.com/api_key</a>
                    </p>
                </div>
            `;
            
            try {
                // Fetch the registry of saved conversations
                const response = await fetch('/comparison_registry.json');
                
                if (response.ok) {
                    const registry = await response.json();
                    
                    if (registry && registry.length > 0) {
                        // Add saved conversations section
                        htmlContent += `
                            <h2 style="font-size: 20px; color: white; margin-bottom: 20px;">Saved Comparisons</h2>
                            <div style="display: flex; flex-direction: column; gap: 15px;">
                                ${registry.map(conv => `
                                    <div style="
                                        background: white;
                                        border-radius: 12px;
                                        padding: 20px;
                                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                                        cursor: pointer;
                                        transition: transform 0.2s, box-shadow 0.2s;
                                    " 
                                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0, 0, 0, 0.15)'" 
                                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.1)'"
                                    onclick="window.location.href='?conversation_id=${conv.id}'">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <div style="flex: 1;">
                                                <h3 style="margin: 0; color: #333; font-size: 16px;">
                                                    ${conv.title.length > 80 ? conv.title.substring(0, 80) + '...' : conv.title}
                                                </h3>
                                                ${conv.description ? `
                                                    <div style="font-size: 14px; color: #666; margin-top: 6px; line-height: 1.4;">
                                                        ${conv.description.length > 150 ? conv.description.substring(0, 150) + '...' : conv.description}
                                                    </div>
                                                ` : ''}
                                                <div style="font-size: 12px; color: #999; margin-top: 8px;">
                                                    ${conv.id.substring(0, 10)}
                                                </div>
                                            </div>
                                            <div style="color: #4a90e2; font-size: 20px; margin-left: 20px;">
                                                →
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
            }
            
            mainContent.innerHTML = htmlContent;
        }
        
        async function showArchiveView(conversationId) {
            const mainContent = document.getElementById('mainContent');
            
            try {
                // Load conversation data
                const response = await fetch(`/comparisons/${conversationId}.json`);
                if (!response.ok) {
                    mainContent.innerHTML = `
                        <div class="no-api-key">
                            <h2>Conversation Not Found</h2>
                            <p>The requested conversation could not be found.</p>
                            <p><a href="/" style="color: #4a90e2;">← Back to Home</a></p>
                        </div>
                    `;
                    return;
                }
                
                const data = await response.json();
                
                // Use the saved models from the conversation
                models = data.models || [];
                messages = data.messages || [];
                requestResponses = data.requestResponses || {};
                
                // Get title and description from registry (they are no longer in individual files)
                let title = 'Archived Conversation';
                let description = '';
                try {
                    const regResponse = await fetch('/comparison_registry.json');
                    if (regResponse.ok) {
                        const registry = await regResponse.json();
                        const convEntry = registry.find(c => c.id === conversationId);
                        if (convEntry) {
                            if (convEntry.title) {
                                title = convEntry.title;
                            }
                            if (convEntry.description) {
                                description = convEntry.description;
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error fetching data from registry:', e);
                }
                
                // Display the archived conversation (similar to chat view but read-only)
                mainContent.innerHTML = `
                    <div class="header">
                        <h1>${title}</h1>
                        <p style="margin: 10px 0;">
                            <a href="/" style="color: #4a90e2; text-decoration: none; margin-right: 20px;">← Back to Conversations</a>
                            <span style="color: #666; font-size: 14px;">${data.datetime || ''}</span>
                        </p>
                    </div>
                    
                    <div class="input-container">
                        ${description ? `
                            <div style="
                                background: #f9f9f9;
                                padding: 16px;
                                border-radius: 8px;
                                margin-bottom: 15px;
                                border: 1px solid #e0e0e0;
                            ">
                                <div id="descriptionContent" style="color: #666; font-size: 14px; line-height: 1.6;">
                                    ${marked.parse(description)}
                                </div>
                            </div>
                        ` : ''}
                        <div class="chat-history" id="chatHistory" style="max-height: 500px;"></div>
                    </div>
                    
                    <div class="models-grid" id="modelsGrid">
                        ${models.map(model => `
                            <div class="model-card">
                                <div class="model-header">
                                    <span>${model}</span>
                                    <span class="model-status" id="status-${model.replace(/\./g, '-')}">Archived</span>
                                </div>
                                <div class="model-response" id="response-${model.replace(/\./g, '-')}">
                                    Click a message above to view responses
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <button onclick="startNewChat()" style="
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        padding: 14px 32px;
                        background: linear-gradient(135deg, #4a90e2 0%, #2c5282 100%);
                        color: white;
                        border: none;
                        border-radius: 12px;
                        font-size: 15px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.2s, box-shadow 0.2s;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                        z-index: 1000;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(74, 144, 226, 0.4)'" 
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'">
                        Start New Chat →
                    </button>
                `;
                
                // Populate chat history with proper interleaving
                const chatHistory = document.getElementById('chatHistory');
                
                // Sort request IDs by timestamp
                const sortedRequestIds = Object.keys(requestResponses).sort((a, b) => parseFloat(a) - parseFloat(b));
                
                // Track which message index we're at
                let messageIndex = 0;
                
                // For each request, add the corresponding user message and then the system message
                sortedRequestIds.forEach(requestId => {
                    const req = requestResponses[requestId];
                    
                    // Add the user message that corresponds to this request
                    if (messageIndex < messages.length) {
                        const msg = messages[messageIndex];
                        if (msg.role === 'user') {
                            const msgDiv = document.createElement('div');
                            msgDiv.className = `message ${msg.role}`;
                            // Escape HTML first, then convert newlines to <br> tags
                            const escapedMessage = msg.content
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;')
                                .replace(/"/g, '&quot;')
                                .replace(/'/g, '&#039;');
                            msgDiv.innerHTML = escapedMessage.replace(/\n/g, '<br>');
                            chatHistory.appendChild(msgDiv);
                            messageIndex++;
                        }
                    }
                    
                    // Add the system message for this request
                    const systemMsg = document.createElement('div');
                    systemMsg.className = 'message system clickable';
                    const successCount = Object.values(req.responses).filter(r => r.status === 'success').length;
                    const totalCount = Object.keys(req.responses).length;
                    systemMsg.textContent = `${successCount}/${totalCount} responded`;
                    systemMsg.dataset.requestId = requestId;
                    systemMsg.onclick = () => restoreResponses(requestId);
                    systemMsg.title = 'Click to view responses';
                    chatHistory.appendChild(systemMsg);
                });
                
                chatHistory.scrollTop = chatHistory.scrollHeight;
                
                // Show the most recent responses by default
                const mostRecentId = Object.keys(requestResponses).sort((a, b) => parseFloat(b) - parseFloat(a))[0];
                if (mostRecentId) {
                    restoreResponses(mostRecentId);
                }
                
            } catch (error) {
                console.error('Error loading conversation:', error);
                mainContent.innerHTML = `
                    <div class="no-api-key">
                        <h2>Error Loading Conversation</h2>
                        <p>Failed to load the conversation. Please try again.</p>
                        <p><a href="/" style="color: #4a90e2;">← Back to Home</a></p>
                    </div>
                `;
            }
        }
        
        async function showChatView() {
            const mainContent = document.getElementById('mainContent');
            
            // Check if there are imported data (messages and responses)
            const importedDataParam = urlParams.get('imported_data');
            const importedMessagesParam = urlParams.get('imported_messages'); // Keep backward compatibility
            
            if (importedDataParam) {
                try {
                    // Parse and import both messages and responses
                    const importedData = JSON.parse(decodeURIComponent(importedDataParam));
                    messages = importedData.messages || [];
                    requestResponses = importedData.requestResponses || {};
                    // Remove the imported_data parameter from URL to avoid re-importing on refresh
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.delete('imported_data');
                    window.history.replaceState({}, document.title, newUrl.toString());
                } catch (e) {
                    console.error('Failed to import data:', e);
                    messages = [];
                    requestResponses = {};
                }
            } else if (importedMessagesParam) {
                // Backward compatibility with old imported_messages parameter
                try {
                    messages = JSON.parse(decodeURIComponent(importedMessagesParam));
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.delete('imported_messages');
                    window.history.replaceState({}, document.title, newUrl.toString());
                } catch (e) {
                    console.error('Failed to import messages:', e);
                    messages = [];
                }
                requestResponses = {};
            } else {
                // Reset for new chat
                messages = [];
                requestResponses = {};
            }
            
            // Get models from URL parameter or fetch from API
            const modelsParam = urlParams.get('models');
            if (modelsParam) {
                models = modelsParam.split(',').map(m => m.trim());
            } else {
                // Fetch available models from Poe API
                mainContent.innerHTML = `
                    <div class="no-api-key">
                        <h2>Loading...</h2>
                        <p>Fetching available models from Poe API...</p>
                    </div>
                `;
                
                const availableModels = await fetchAvailableModels();
                if (!availableModels || availableModels.length === 0) {
                    mainContent.innerHTML = `
                        <div class="no-api-key">
                            <h2>⚠️ Failed to Load Models</h2>
                            <p>Please check that your API key is correct.</p>
                            <p>Current API key: <code>${apiKey}</code></p>
                        </div>
                    `;
                    return;
                }
                
                // Filter to official models only (no custom bots with ':')
                const officialModels = availableModels.filter(model => !model.includes(':'));
                
                // Select best model for each prefix
                const prefixes = ['GPT-5', 'Claude-Opus', 'Gemini', 'Grok', 'Qwen', 'Kimi', 'Deepseek', 'Mistral', 'Llama', 'GPT-4', 'GPT-3', 'Claude-Sonnet'];
                models = [];
                
                for (const prefix of prefixes) {
                    // Find all models starting with this prefix
                    const prefixModels = officialModels.filter(model => 
                        model.toLowerCase().startsWith(prefix.toLowerCase())
                    );
                    
                    if (prefixModels.length > 0) {
                        // Filter out models that have a shorter prefix model in the list

                        // console.log(prefixModels);

                        const mainModels = prefixModels.filter(model => {
                            return !prefixModels.some(otherModel => 
                                otherModel !== model
                                && model.toLowerCase().startsWith(otherModel.toLowerCase())
                                && !model.toLowerCase().startsWith(otherModel.toLowerCase() + ".")
                            );
                        });

                        // console.log(mainModels);
                        
                        // If we have main models, pick from them
                        let candidates = mainModels.length > 0 ? mainModels : prefixModels;
                        
                        // Sort candidates and pick the lexicographically largest
                        // This tends to pick newer versions (e.g., GPT-5 over GPT-4)
                        candidates.sort();

                        // console.log(mainModels);

                        const selected = candidates[candidates.length - 1];
                        
                        if (selected) {
                            models.push(selected);
                        }
                    }
                }
            }

            // Add save comparison button only on localhost
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const saveButtonHtml = isLocalhost ? 
                '<button id="saveComparisonButton" class="save-comparison-button">Save Comparison</button>' : '';
            
            mainContent.innerHTML = `
                <div class="input-container">
                    <form id="chatForm" class="input-form">
                        <textarea id="messageInput" class="message-input" placeholder="Ask anything..." rows="1" autofocus></textarea>
                        <button type="submit" id="sendButton" class="send-button">Send</button>
                    </form>
                    <div class="chat-history" id="chatHistory"></div>
                </div>
                
                <div class="models-grid" id="modelsGrid">
                    ${models.map(model => `
                        <div class="model-card">
                            <div class="model-header">
                                <span>${model}</span>
                                <span class="model-status" id="status-${model.replace(/\./g, '-')}">Ready</span>
                            </div>
                            <div class="model-response" id="response-${model.replace(/\./g, '-')}">
                                Ready
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                ${saveButtonHtml}
            `;

            // If there are imported messages and responses, display them in the chat history
            if (messages.length > 0 || Object.keys(requestResponses).length > 0) {
                const chatHistory = document.getElementById('chatHistory');
                
                // Sort request IDs by timestamp
                const sortedRequestIds = Object.keys(requestResponses).sort((a, b) => parseFloat(a) - parseFloat(b));
                
                // Track which message index we're at
                let messageIndex = 0;
                
                // For each request, add the corresponding user message and then the system message
                sortedRequestIds.forEach(requestId => {
                    const req = requestResponses[requestId];
                    
                    // Add the user message that corresponds to this request
                    if (messageIndex < messages.length) {
                        const msg = messages[messageIndex];
                        if (msg.role === 'user') {
                            const msgDiv = document.createElement('div');
                            msgDiv.className = `message ${msg.role}`;
                            // Escape HTML first, then convert newlines to <br> tags
                            const escapedMessage = msg.content
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;')
                                .replace(/"/g, '&quot;')
                                .replace(/'/g, '&#039;');
                            msgDiv.innerHTML = escapedMessage.replace(/\n/g, '<br>');
                            chatHistory.appendChild(msgDiv);
                            messageIndex++;
                        }
                    }
                    
                    // Add the system message for this request
                    const systemMsg = document.createElement('div');
                    systemMsg.className = 'message system clickable';
                    const successCount = Object.values(req.responses).filter(r => r.status === 'success').length;
                    const totalCount = Object.keys(req.responses).length;
                    systemMsg.textContent = `${successCount}/${totalCount} responded`;
                    systemMsg.dataset.requestId = requestId;
                    systemMsg.onclick = () => restoreResponses(requestId);
                    systemMsg.title = 'Click to view responses';
                    chatHistory.appendChild(systemMsg);
                });
                
                // Add any remaining messages that don't have responses yet
                while (messageIndex < messages.length) {
                    const msg = messages[messageIndex];
                    const msgDiv = document.createElement('div');
                    msgDiv.className = `message ${msg.role}`;
                    const escapedMessage = msg.content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');
                    msgDiv.innerHTML = escapedMessage.replace(/\n/g, '<br>');
                    chatHistory.appendChild(msgDiv);
                    messageIndex++;
                }
                
                chatHistory.scrollTop = chatHistory.scrollHeight;
                
                // Show the most recent responses by default
                const mostRecentId = sortedRequestIds[sortedRequestIds.length - 1];
                if (mostRecentId) {
                    restoreResponses(mostRecentId);
                }
            }
            
            // Set up event listeners
            document.getElementById('chatForm').addEventListener('submit', handleSubmit);
            
            // Set up textarea auto-resize and keyboard handling
            const messageInput = document.getElementById('messageInput');
            
            // Auto-resize textarea as user types
            messageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 200) + 'px';
            });
            
            // Handle Enter vs Shift+Enter
            messageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    document.getElementById('chatForm').dispatchEvent(new Event('submit'));
                }
            });
            
            // Set up save comparison button if it exists
            if (isLocalhost) {
                const saveButton = document.getElementById('saveComparisonButton');
                if (saveButton) {
                    saveButton.addEventListener('click', saveComparison);
                }
            }
        }

        async function handleSubmit(e) {
            e.preventDefault();
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            const sendButton = document.getElementById('sendButton');
            const chatHistory = document.getElementById('chatHistory');
            
            // Add user message to history (ALWAYS show what user typed)
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'message user';
            // Escape HTML first, then convert newlines to <br> tags
            const escapedMessage = message
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            userMessageDiv.innerHTML = escapedMessage.replace(/\n/g, '<br>');
            chatHistory.appendChild(userMessageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            // Add to messages array
            messages.push({ role: 'user', content: message });
            
            // Clear input but keep button enabled
            input.value = '';
            input.focus();
            
            // Check which models are available
            const modelsToQuery = [];
            
            // If there are already queued messages, this one must also be queued to maintain order
            if (messageQueue.length > 0) {
                console.log('Previous messages are queued - adding this message to queue to maintain order');
                modelsToQuery.length = 0; // Force queueing
            } else {
                models.forEach(model => {
                    const modelId = model.replace(/\./g, '-');
                    const statusEl = document.getElementById(`status-${modelId}`);
                    const responseEl = document.getElementById(`response-${modelId}`);
                    
                    if (!modelsLoading.has(model)) {
                        // Model is available, reset it and add to query list
                        statusEl.className = 'model-status loading';
                        statusEl.textContent = 'Loading...';
                        responseEl.className = 'model-response loading';
                        responseEl.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
                        modelsToQuery.push(model);
                        modelsLoading.add(model);
                        console.log(`Adding ${model} to loading set`);
                    } else {
                        // Model is still loading from previous request, show status
                        console.log(`${model} is still loading from previous request`);
                        if (!statusEl.textContent.includes('Busy')) {
                            statusEl.textContent = 'Busy...';
                        }
                    }
                });
            }
            
            // If no models to query, add to queue for later processing
            if (modelsToQuery.length === 0) {
                console.log('All models busy - adding message to queue');
                
                // Create a placeholder with a unique ID that will be updated later
                const placeholderId = 'queued-' + Date.now() + Math.random();
                
                messageQueue.push({
                    message: message,
                    timestamp: new Date(),
                    placeholderId: placeholderId,
                    pendingModels: [...models], // Track which models should handle this message
                    messagesSnapshot: [...messages] // Store the conversation state at this point
                });
                
                // Add a system message placeholder that will be updated when processed
                const queuedMessage = document.createElement('div');
                queuedMessage.className = 'message system';
                queuedMessage.textContent = 'Queued (all models busy)';
                queuedMessage.id = placeholderId;
                chatHistory.appendChild(queuedMessage);
                chatHistory.scrollTop = chatHistory.scrollHeight;
                return;
            }
            
            // Create a unique ID for this request
            const requestId = Date.now() + Math.random();
            
            // Initialize response storage for this request
            requestResponses[requestId] = {
                question: message,
                responses: {},
                timestamp: new Date()
            };
            
            // Add placeholder for system message - make it clickable immediately
            const systemPlaceholder = document.createElement('div');
            systemPlaceholder.className = 'message system clickable';
            if (modelsToQuery.length < models.length) {
                systemPlaceholder.textContent = `Sending to ${modelsToQuery.length} models (${models.length - modelsToQuery.length} busy)`;
            } else {
                systemPlaceholder.textContent = 'Sending to all models...';
            }
            systemPlaceholder.dataset.requestId = requestId;
            systemPlaceholder.onclick = () => restoreResponses(requestId);
            systemPlaceholder.title = 'Click to view current responses';
            chatHistory.appendChild(systemPlaceholder);
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            // Query only available models in parallel (don't await)
            // Send the entire conversation history
            const modelPromises = modelsToQuery.map(model => queryModel(model, messages, requestId));
            
            // Track responses
            let successCount = 0;
            let errorCount = 0;
            const totalModels = modelsToQuery.length; // Only count models we're actually querying
            let completedCount = 0;
            
            // Update status as each model completes
            modelPromises.forEach((promise, index) => {
                const model = modelsToQuery[index]; // Get the model name for this promise
                promise.then(success => {
                    completedCount++;
                    if (success) successCount++;
                    else errorCount++;
                    
                    // Update the placeholder text as responses come in
                    const placeholder = chatHistory.querySelector(`[data-request-id="${requestId}"]`);
                    if (placeholder) {
                        if (completedCount === totalModels) {
                            placeholder.textContent = successCount === totalModels ? 
                                'All models responded' : 
                                `${successCount}/${totalModels} responded`;
                        } else {
                            placeholder.textContent = `Loading... (${completedCount}/${totalModels})`;
                        }
                    }
                }).catch(() => {
                    completedCount++;
                    errorCount++;
                    // Make sure to remove from loading set on error in promise chain
                    modelsLoading.delete(model);
                    const placeholder = chatHistory.querySelector(`[data-request-id="${requestId}"]`);
                    if (placeholder) {
                        placeholder.textContent = `Loading... (${completedCount}/${totalModels} completed)`;
                    }
                });
            });
            
            // Handle final completion
            Promise.allSettled(modelPromises).then((results) => {
                // Final counts are already tracked in the individual promises
                // Just ensure final UI state
                const placeholder = chatHistory.querySelector(`[data-request-id="${requestId}"]`);
                if (placeholder) {
                    if (successCount === totalModels) {
                        placeholder.textContent = 'All models responded';
                    } else if (successCount > 0) {
                        placeholder.textContent = `${successCount}/${totalModels} responded`;
                    } else {
                        placeholder.textContent = 'All failed';
                    }
                    
                    // Keep it clickable (it's already set up)
                    if (successCount === 0) {
                        // Only remove clickable if completely failed
                        placeholder.className = 'message system';
                        placeholder.onclick = null;
                        placeholder.title = '';
                    }
                }
                chatHistory.scrollTop = chatHistory.scrollHeight;
            });
        }

        async function queryModel(model, messages, requestId) {
            const modelId = model.replace(/\./g, '-');
            const statusEl = document.getElementById(`status-${modelId}`);
            const responseEl = document.getElementById(`response-${modelId}`);
            const startTime = Date.now();
            
            // Build conversation history with this model's previous responses
            const conversationHistory = [];
            for (let i = 0; i < messages.length; i++) {
                const msg = messages[i];
                conversationHistory.push(msg);
                
                // After each user message (except the last), add the model's response if it exists
                if (msg.role === 'user' && i < messages.length - 1) {
                    // Find the response for this message from previous requests
                    const previousRequests = Object.keys(requestResponses).sort((a, b) => parseFloat(a) - parseFloat(b));
                    for (const prevReqId of previousRequests) {
                        if (parseFloat(prevReqId) >= parseFloat(requestId)) break; // Don't include current or future
                        const prevReq = requestResponses[prevReqId];
                        if (prevReq.question === msg.content && prevReq.responses[model]) {
                            if (prevReq.responses[model].status === 'success') {
                                conversationHistory.push({
                                    role: 'assistant',
                                    content: prevReq.responses[model].content
                                });
                                break;
                            }
                        }
                    }
                }
            }
            
            try {
                const response = await fetch(`${baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: conversationHistory,
                        stream: false
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorData}`);
                }
                
                const data = await response.json();
                const responseTime = ((Date.now() - startTime) / 1000).toFixed(1);
                const content = data.choices[0].message.content;
                
                // Store the response first
                if (requestId && requestResponses[requestId]) {
                    requestResponses[requestId].responses[model] = {
                        content: content,
                        responseTime: responseTime,
                        status: 'success'
                    };
                }
                
                // Only update display if this is the most recent request
                // (check if there's a newer request in the responses)
                const allRequestIds = Object.keys(requestResponses).map(id => parseFloat(id)).sort((a, b) => b - a);
                const isLatestRequest = allRequestIds[0] === parseFloat(requestId);
                
                if (isLatestRequest) {
                    statusEl.className = 'model-status success';
                    statusEl.textContent = `✓ ${responseTime}s`;
                    responseEl.className = 'model-response';
                    renderContent(responseEl, content);
                }
                
                // Remove from loading set
                modelsLoading.delete(model);
                console.log(`Removed ${model} from loading set (success)`);
                
                // Check if we should process queued messages
                processQueuedMessages();
                
                return true;
                
            } catch (error) {
                // Store the error first
                if (requestId && requestResponses[requestId]) {
                    requestResponses[requestId].responses[model] = {
                        content: error.message,
                        responseTime: ((Date.now() - startTime) / 1000).toFixed(1),
                        status: 'error'
                    };
                }
                
                // Only update display if this is the most recent request
                const allRequestIds = Object.keys(requestResponses).map(id => parseFloat(id)).sort((a, b) => b - a);
                const isLatestRequest = allRequestIds[0] === parseFloat(requestId);
                
                if (isLatestRequest) {
                    statusEl.className = 'model-status error';
                    statusEl.textContent = 'Error';
                    responseEl.className = 'model-response';
                    responseEl.innerHTML = `<span class="error-text">Error: ${error.message}</span>`;
                }
                
                // Remove from loading set even on error
                modelsLoading.delete(model);
                console.log(`Removed ${model} from loading set (error)`);
                
                // Check if we should process queued messages
                processQueuedMessages();
                
                return false;
            }
        }

        // Process queued messages when models become available
        function processQueuedMessages() {
            // Check if we have queued messages
            if (messageQueue.length === 0) return;
            
            // Find the first queued message where ALL its required models are available
            let queuedIndex = -1;
            let queued = null;
            
            for (let i = 0; i < messageQueue.length; i++) {
                const msg = messageQueue[i];
                // Check if all models this message needs are available
                const availableForMessage = msg.pendingModels.filter(model => !modelsLoading.has(model));
                if (availableForMessage.length === msg.pendingModels.length) {
                    // All models for this message are available
                    queuedIndex = i;
                    queued = msg;
                    break;
                }
            }
            
            // If no message has all its models available, return
            if (!queued) return;
            
            // Remove this message from the queue
            messageQueue.splice(queuedIndex, 1);
            console.log(`Processing queued message: ${queued.message}`);
            
            // Create a unique ID for this request
            const requestId = Date.now() + Math.random();
            
            // Initialize response storage for this request
            requestResponses[requestId] = {
                question: queued.message,
                responses: {},
                timestamp: queued.timestamp
            };
            
            // Find and update the existing placeholder (don't create a new one)
            const chatHistory = document.getElementById('chatHistory');
            const placeholder = document.getElementById(queued.placeholderId);
            if (placeholder) {
                // Update the existing placeholder
                placeholder.className = 'message system clickable';
                placeholder.textContent = `Processing (${queued.pendingModels.length} models)...`;
                placeholder.dataset.requestId = requestId;
                placeholder.onclick = () => restoreResponses(requestId);
                placeholder.title = 'Click to view current responses';
                placeholder.removeAttribute('id'); // Remove the temporary ID
            } else {
                // Fallback: create a new one if placeholder not found
                const systemPlaceholder = document.createElement('div');
                systemPlaceholder.className = 'message system clickable';
                systemPlaceholder.textContent = `Processing (${queued.pendingModels.length} models)...`;
                systemPlaceholder.dataset.requestId = requestId;
                systemPlaceholder.onclick = () => restoreResponses(requestId);
                systemPlaceholder.title = 'Click to view current responses';
                chatHistory.appendChild(systemPlaceholder);
            }
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            // Query all the models that were originally intended for this message
            const modelPromises = [];
            queued.pendingModels.forEach(model => {
                const modelId = model.replace(/\./g, '-');
                const statusEl = document.getElementById(`status-${modelId}`);
                const responseEl = document.getElementById(`response-${modelId}`);
                
                // Reset UI
                statusEl.className = 'model-status loading';
                statusEl.textContent = 'Loading...';
                responseEl.className = 'model-response loading';
                responseEl.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
                
                // Mark as loading
                modelsLoading.add(model);
                console.log(`Adding ${model} to loading set (queued message)`);
                
                // Query the model - send the conversation history snapshot
                modelPromises.push(queryModel(model, queued.messagesSnapshot, requestId));
            });
            
            // Track responses
            let successCount = 0;
            let errorCount = 0;
            const totalModels = queued.pendingModels.length;
            let completedCount = 0;
            
            // Update status as each model completes
            modelPromises.forEach((promise, index) => {
                const model = queued.pendingModels[index];
                promise.then(success => {
                    completedCount++;
                    if (success) successCount++;
                    else errorCount++;
                    
                    // Update the placeholder text (find by requestId)
                    const placeholder = chatHistory.querySelector(`[data-request-id="${requestId}"]`);
                    if (placeholder) {
                        if (completedCount === totalModels) {
                            placeholder.textContent = successCount === totalModels ? 
                                'All models responded' : 
                                `${successCount}/${totalModels} responded`;
                        } else {
                            placeholder.textContent = `Loading... (${completedCount}/${totalModels})`;
                        }
                    }
                }).catch(() => {
                    completedCount++;
                    errorCount++;
                    modelsLoading.delete(model);
                    const placeholder = chatHistory.querySelector(`[data-request-id="${requestId}"]`);
                    if (placeholder) {
                        placeholder.textContent = `Loading... (${completedCount}/${totalModels} completed)`;
                    }
                });
            });
        }
        
        // Function to restore responses in the model boxes
        function restoreResponses(requestId) {
            if (!requestResponses[requestId]) {
                return;
            }
            
            const data = requestResponses[requestId];
            const responses = data.responses;
            
            // Restore each model's response in its box
            for (const [model, response] of Object.entries(responses)) {
                const modelId = model.replace(/\./g, '-');
                const statusEl = document.getElementById(`status-${modelId}`);
                const responseEl = document.getElementById(`response-${modelId}`);
                
                if (statusEl && responseEl) {
                    // Restore status
                    if (response.status === 'success') {
                        statusEl.className = 'model-status success';
                        statusEl.textContent = `✓ ${response.responseTime}s`;
                        responseEl.className = 'model-response';
                        renderContent(responseEl, response.content);
                    } else {
                        statusEl.className = 'model-status error';
                        statusEl.textContent = 'Error';
                        responseEl.className = 'model-response';
                        responseEl.innerHTML = `<span class="error-text">Error: ${response.content}</span>`;
                    }
                }
            }
        }

        // Function to render markdown and LaTeX content
        function renderContent(element, content) {
            // First, parse markdown to HTML
            const htmlContent = marked.parse(content);
            
            // Set the HTML content
            element.innerHTML = htmlContent;
            
            // Then render LaTeX math
            if (window.renderMathInElement) {
                renderMathInElement(element, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        }
        
        // Function to show save modal
        function showSaveModal() {
            return new Promise((resolve) => {
                // Create modal overlay
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                
                // Create modal content
                const modal = document.createElement('div');
                modal.className = 'modal';
                
                // Get the first user message to use for title suggestion
                const firstUserMessage = messages.find(m => m.role === 'user');
                const suggestedTitle = firstUserMessage ? 
                    firstUserMessage.content.split(' ').slice(0, 10).join(' ') : 
                    'Untitled Comparison';
                
                modal.innerHTML = `
                    <h2>Save Comparison</h2>
                    <p style="color: #666; margin-bottom: 15px;">Add a description for this conversation:</p>
                    <textarea 
                        id="descriptionInput" 
                        class="modal-input" 
                        placeholder="Describe what this conversation is about, key findings, or anything noteworthy..."
                        autofocus
                    ></textarea>
                    <div class="modal-buttons">
                        <button class="modal-button secondary" id="cancelButton">Cancel</button>
                        <button class="modal-button primary" id="confirmButton">Save</button>
                    </div>
                `;
                
                modalOverlay.appendChild(modal);
                document.body.appendChild(modalOverlay);
                
                // Focus the textarea
                const descriptionInput = document.getElementById('descriptionInput');
                descriptionInput.focus();
                
                // Handle button clicks
                const handleSave = () => {
                    const description = descriptionInput.value.trim();
                    cleanup();
                    resolve({ confirmed: true, description });
                };
                
                const handleCancel = () => {
                    cleanup();
                    resolve({ confirmed: false });
                };
                
                const cleanup = () => {
                    document.body.removeChild(modalOverlay);
                };
                
                document.getElementById('confirmButton').addEventListener('click', handleSave);
                document.getElementById('cancelButton').addEventListener('click', handleCancel);
                
                // Handle Enter key (Ctrl/Cmd+Enter to save)
                descriptionInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        handleSave();
                    }
                });
                
                // Handle Escape key
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) {
                        handleCancel();
                    }
                });
                
                document.addEventListener('keydown', function escapeHandler(e) {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                });
            });
        }
        
        // Function to save comparison
        async function saveComparison() {
            const saveButton = document.getElementById('saveComparisonButton');
            if (!saveButton) return;
            
            // Check if there are any messages
            if (messages.length === 0) {
                return;
            }
            
            // Show modal to get description
            const modalResult = await showSaveModal();
            
            if (!modalResult.confirmed) {
                return; // User cancelled
            }
            
            // Disable button while saving
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';
            
            try {
                // Get the first user message to use for title
                const firstUserMessage = messages.find(m => m.role === 'user');
                const title = firstUserMessage ? 
                    firstUserMessage.content.split(' ').slice(0, 10).join(' ') : 
                    'Untitled Comparison';
                
                // Create timestamp for ID (format: YYYY-MM-DD-HH-MM-SS)
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const id = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
                
                // Format datetime as YYYY-MM-DD HH:MM:SS
                const datetimeStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                
                // Prepare comparison data
                const comparisonData = {
                    id: id,
                    title: title,
                    description: modalResult.description, // Add description from modal
                    datetime: datetimeStr,
                    messages: messages,
                    requestResponses: requestResponses,
                    models: models,
                    savedAt: now.toISOString()
                };
                
                // Save to server (only works on localhost)
                const response = await fetch('/save-comparison', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(comparisonData)
                });
                
                if (response.ok) {
                    saveButton.textContent = 'Saved!';
                    setTimeout(() => {
                        saveButton.textContent = 'Save Comparison';
                        saveButton.disabled = false;
                    }, 2000);
                } else {
                    throw new Error('Failed to save comparison');
                }
                
            } catch (error) {
                console.error('Error saving comparison:', error);
                saveButton.textContent = 'Save Failed';
                setTimeout(() => {
                    saveButton.textContent = 'Save Comparison';
                    saveButton.disabled = false;
                }, 2000);
            }
        }
        
        // Function to show API key modal
        function showApiKeyModal(isImporting = false) {
            return new Promise((resolve) => {
                // Create modal overlay
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                
                // Create modal content
                const modal = document.createElement('div');
                modal.className = 'modal';
                
                const title = isImporting ? 'Import Conversation' : 'Start New Chat';
                const description = isImporting 
                    ? 'Enter your Poe API key to start a new chat with this conversation imported:'
                    : 'Enter your Poe API key to start a new chat:';
                
                modal.innerHTML = `
                    <h2>${title}</h2>
                    <p style="color: #666; margin-bottom: 15px;">${description}</p>
                    <input type="text" 
                        id="apiKeyModalInput" 
                        class="modal-input" 
                        placeholder="Your Poe API key"
                        style="min-height: 50px; resize: none;"
                        autofocus
                    >
                    <p style="margin-top: 10px; margin-bottom: 15px; color: #666; font-size: 13px;">
                        Get your API key from <a href="https://poe.com/api_key" target="_blank" style="color: #4a90e2;">poe.com/api_key</a>
                    </p>
                    <div class="modal-buttons">
                        <button class="modal-button secondary" id="cancelApiKeyButton">Cancel</button>
                        <button class="modal-button primary" id="confirmApiKeyButton">Start Chat</button>
                    </div>
                `;
                
                modalOverlay.appendChild(modal);
                document.body.appendChild(modalOverlay);
                
                // Focus the input
                const apiKeyInput = document.getElementById('apiKeyModalInput');
                apiKeyInput.focus();
                
                // Handle button clicks
                const handleConfirm = () => {
                    const apiKey = apiKeyInput.value.trim();
                    cleanup();
                    resolve(apiKey);
                };
                
                const handleCancel = () => {
                    cleanup();
                    resolve(null);
                };
                
                const cleanup = () => {
                    document.body.removeChild(modalOverlay);
                };
                
                document.getElementById('confirmApiKeyButton').addEventListener('click', handleConfirm);
                document.getElementById('cancelApiKeyButton').addEventListener('click', handleCancel);
                
                // Handle Enter key
                apiKeyInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        handleConfirm();
                    }
                });
                
                // Handle Escape key
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) {
                        handleCancel();
                    }
                });
                
                document.addEventListener('keydown', function escapeHandler(e) {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                });
            });
        }
        
        // Function to start a new chat
        async function startNewChat() {
            // Check if we're in archive view (have a conversation_id)
            const conversationId = urlParams.get('conversation_id');
            
            const isImporting = !!conversationId;
            const apiKey = await showApiKeyModal(isImporting);
            
            if (apiKey) {
                if (conversationId) {
                    // Import both messages and responses
                    const dataToImport = {
                        messages: messages,
                        requestResponses: requestResponses
                    };
                    const encodedData = encodeURIComponent(JSON.stringify(dataToImport));
                    window.location.href = `?api_key=${encodeURIComponent(apiKey)}&imported_data=${encodedData}`;
                } else {
                    window.location.href = `?api_key=${encodeURIComponent(apiKey)}`;
                }
            }
        }
        
        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>